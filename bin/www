#!/usr/bin/env node

/**
 * Module dependencies.
 */

const path = require('path');
const App = require('../app');
const http = require('http');
const download = require('../lib/downloadrmlmapper');
const fs = require('fs-extra');
const winston = require('winston');
const logger = require('../lib/logger');

const DEFAULT_RMLMAPPER_PATH = path.resolve(__dirname, '../rmlmapper.jar');
const DEFAULT_RMLMAPPER_VERSION_PATH = path.resolve(__dirname, '../rmlmapper-version.txt');
const configPath = path.resolve(process.cwd(), 'config.json');
let server;
let config = {};

if (fs.pathExistsSync(configPath)) {
  config = require(configPath);
}

if (!config.logLevel) {
  config.logLevel = 'info';
}

if (!config.port) {
  config.port = 4000;
} else {
  config.port = parseInt(config.port);
}

logger.configure({
  level: config.logLevel,
  format: winston.format.json(),
  transports: [
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});

// we do this if again, because the config needs to be read first before we can start the logger.
if (fs.pathExistsSync(configPath)) {
  logger.info(`Using config file at ${configPath}.`);
}

start();

async function start() {
  /**
   * Check if RMLMapper is defined.
   */

  if (!config.rmlmapper || !config.rmlmapper.path) {
    logger.info('No path to an RMLMapper jar is defined.');
    let version;

    if (!fs.existsSync(DEFAULT_RMLMAPPER_PATH)) {
      try {
        version = await download(DEFAULT_RMLMAPPER_PATH);
        fs.writeFileSync(DEFAULT_RMLMAPPER_VERSION_PATH, version, 'utf-8');

        logger.info(`Using the RMLMapper jar at ${DEFAULT_RMLMAPPER_PATH} (${version}).`);
      } catch (e) {
        console.error(e);
        process.exit(1);
      }
    } else {
      version = fs.readFileSync(DEFAULT_RMLMAPPER_VERSION_PATH, 'utf-8');
      logger.info(`Usig the default jar at ${DEFAULT_RMLMAPPER_PATH} (${version}).`);
    }

    config.rmlmapper = {
      path: DEFAULT_RMLMAPPER_PATH,
      version
    };
  }

  /**
   * Get port from environment and store in Express.
   */

  const app = new App(config);
  app.set('port', config.port);

  /**
   * Create HTTP server.
   */

  server = http.createServer(app);

  /**
   * Listen on provided port, on all network interfaces.
   */

  server.listen(config.port);
  server.on('error', onError);
  server.on('listening', onListening);
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      logger.error('Port ' + config.port + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      logger.error('Port ' + config.port + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  logger.info('Listening on port ' + server.address().port);
}

